name: build-crankshaft-refactored

on:
  # Schedule builds (commented out initially)
  # schedule:
  #   - cron: '0 10 * * *' # everyday at 10am
  workflow_dispatch:
    inputs:
      version:
        description: 'Version'
        required: true
        default: 'DEV'
        type: string
      target_arch:
        description: 'Target Architecture'
        required: false
        default: 'armhf'
        type: choice
        options:
          - armhf
          - arm64
      release:
        description: 'Debian Release'
        required: false
        default: 'trixie'
        type: choice
        options:
          - trixie
          - bookworm
  push:
    branches:
      - main
    paths:
      - 'crankshaft/**'
  pull_request:
    paths:
      - 'crankshaft/**'

env:
  # Default configuration
  DEBIAN_FRONTEND: noninteractive

jobs:
  buildimage:
    runs-on: ubuntu-latest
    timeout-minutes: 480  # 8 hours max build time
    outputs:
      artifact_path: ${{ steps.get-artifact-name.outputs.artifact_path }}
      artifact_filename: ${{ steps.get-artifact-name.outputs.artifact_filename }}
      md5_path: ${{ steps.get-artifact-name.outputs.md5_path }}
      md5_filename: ${{ steps.get-artifact-name.outputs.md5_filename }}
      sha1_path: ${{ steps.get-artifact-name.outputs.sha1_path }}
      sha1_filename: ${{ steps.get-artifact-name.outputs.sha1_filename }}
      sha256_path: ${{ steps.get-artifact-name.outputs.sha256_path }}
      sha256_filename: ${{ steps.get-artifact-name.outputs.sha256_filename }}
      version: ${{ steps.get_version.outputs.version }}
      builddate: ${{ steps.get_version.outputs.builddate }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper git information
          
      - name: Set up QEMU for multi-architecture builds
        uses: docker/setup-qemu-action@v3
        with:
          image: tonistiigi/binfmt:latest
          platforms: all
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Free up disk space
        run: |
          # Remove unnecessary packages to free up space
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          df -h
          
      - name: Get build version and metadata
        id: get_version
        run: |
          # Extract version from input or default
          VERSION="${{ github.event.inputs.version || 'DEV' }}"
          ARCH="${{ github.event.inputs.target_arch || 'armhf' }}"
          RELEASE="${{ github.event.inputs.release || 'trixie' }}"
          
          # Get git information
          BUILD_HASH=$(git rev-parse --short "$GITHUB_SHA")
          BUILD_DATE=$(date '+%Y-%m-%d')
          BUILD_BRANCH="crankshaft-refactored"
          
          # Create version string
          if [ "$VERSION" = "DEV" ]; then
            VERSION_STRING="${BUILD_DATE}-${BUILD_BRANCH}-${BUILD_HASH}"
          else
            VERSION_STRING="${VERSION}-${BUILD_DATE}-${BUILD_HASH}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_string=${VERSION_STRING}" >> $GITHUB_OUTPUT
          echo "buildhash=${BUILD_HASH}" >> $GITHUB_OUTPUT
          echo "buildbranch=${BUILD_BRANCH}" >> $GITHUB_OUTPUT
          echo "builddate=${BUILD_DATE}" >> $GITHUB_OUTPUT
          echo "arch=${ARCH}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          
          echo "Build Version: ${VERSION_STRING}"
          echo "Architecture: ${ARCH}"
          echo "Release: ${RELEASE}"
          
      - name: Configure build
        id: configure
        working-directory: crankshaft
        run: |
          # Create configuration file
          cat > config <<EOF
          IMG_NAME=\${VERSION_STRING}
          ENABLE_SSH=0
          
          # Build metadata  
          IMG_VERSION=\${VERSION_STRING}
          IMG_FILENAME=\${VERSION_STRING}
          ZIP_FILENAME=\${VERSION_STRING}
          BUILDHASH='\${BUILDHASH}'
          BUILDBRANCH='\${BUILDBRANCH}'
          BUILDDATE='\${BUILDDATE}'
          EOF
          
          # Make all shell scripts executable
          find . -type f -iname "*.sh" -exec chmod +x {} \;
          
          # Display configuration
          echo "=== Build Configuration ==="
          cat config
          echo "=========================="
          
        env:
          VERSION_STRING: ${{ steps.get_version.outputs.version_string }}
          BUILDHASH: ${{ steps.get_version.outputs.buildhash }}
          BUILDBRANCH: ${{ steps.get_version.outputs.buildbranch }}
          BUILDDATE: ${{ steps.get_version.outputs.builddate }}
          ARCH: ${{ steps.get_version.outputs.arch }}
          RELEASE: ${{ steps.get_version.outputs.release }}
          
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            coreutils quilt parted qemu-user-static debootstrap zerofree zip \
            dosfstools e2fsprogs libarchive-tools libcap2-bin grep rsync xz-utils \
            file git curl bc gpg pigz xxd arch-test bmap-tools kmod
            
      - name: Check Docker environment
        run: |
          echo "=== Docker Environment Check ==="
          docker --version
          docker info
          echo "Docker service status:"
          sudo systemctl status docker --no-pager || echo "systemctl not available"
          echo "================================="
            
      - name: Build crankshaft image using Docker
        id: build-docker
        working-directory: crankshaft
        run: |
          echo "Starting Docker build..."
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          
          # Ensure build-docker.sh is executable
          chmod +x build-docker.sh
          
          # Check if config file exists
          if [ ! -f config ]; then
            echo "Error: config file not found!"
            exit 1
          fi
          
          echo "Config file contents:"
          cat config
          
          # Check Docker environment
          docker --version
          docker info | head -20
          
          # Run the docker build
          echo "Executing: ./build-docker.sh"
          ./build-docker.sh
          
          # Check what was produced
          echo "Build completed. Checking results..."
          if [ -d deploy ]; then
            echo "Deploy directory contents:"
            ls -la deploy/
          else
            echo "No deploy directory found!"
          fi
          
          if [ -d work ]; then
            echo "Work directory contents:"
            find work -name "*.log" -exec echo "Log file: {}" \; -exec tail -20 {} \;
          fi
        env:
          GIT_HASH: ${{ steps.get_version.outputs.buildhash }}
          GIT_BRANCH: ${{ steps.get_version.outputs.buildbranch }}
          
      - name: Verify build output
        working-directory: crankshaft
        run: |
          echo "=== Build Output ==="
          ls -la deploy/ || echo "No deploy directory found"
          echo "==================="
          
          if [ -d deploy ]; then
            echo "=== Deploy Directory Contents ==="
            find deploy -type f -exec ls -lh {} \;
            echo "================================="
          fi
          
      - name: Get artifact information
        id: get-artifact-name
        working-directory: crankshaft
        run: |
          echo "=== Deploy Directory Contents ==="
          ls -hla deploy/ || echo "No deploy directory found"
          
          if [ ! -d deploy ]; then
            echo "Error: Deploy directory not found!"
            exit 1
          fi
          
          # List all files in deploy directory
          find deploy -type f -exec ls -lh {} \;
          
          # The original build produces .zip files, so look for those first
          # But also check for .xz files from modern compression
          ARTIFACT_PATHNAME=""
          if ls deploy/*.zip >/dev/null 2>&1; then
            ARTIFACT_PATHNAME=$(ls deploy/*.zip | head -n 1)
          elif ls deploy/*.xz >/dev/null 2>&1; then  
            ARTIFACT_PATHNAME=$(ls deploy/*.xz | head -n 1)
          elif ls deploy/*.img >/dev/null 2>&1; then
            ARTIFACT_PATHNAME=$(ls deploy/*.img | head -n 1)
          fi
          
          if [ -z "$ARTIFACT_PATHNAME" ]; then
            echo "Error: No image artifact found in deploy directory!"
            echo "Available files:"
            ls -la deploy/
            exit 1
          fi
          
          ARTIFACT_NAME=$(basename "$ARTIFACT_PATHNAME")
          
          # Find checksum files - they might have different extensions
          MD5_PATHNAME=$(find deploy -name "*.md5" | head -n 1)
          SHA1_PATHNAME=$(find deploy -name "*.sha1" | head -n 1) 
          SHA256_PATHNAME=$(find deploy -name "*.sha256" | head -n 1)
          
          # Set outputs using modern format
          echo "artifact_filename=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "artifact_path=${ARTIFACT_PATHNAME}" >> $GITHUB_OUTPUT
          
          if [ -n "$MD5_PATHNAME" ]; then
            echo "md5_filename=$(basename "$MD5_PATHNAME")" >> $GITHUB_OUTPUT
            echo "md5_path=${MD5_PATHNAME}" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$SHA1_PATHNAME" ]; then
            echo "sha1_filename=$(basename "$SHA1_PATHNAME")" >> $GITHUB_OUTPUT
            echo "sha1_path=${SHA1_PATHNAME}" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$SHA256_PATHNAME" ]; then
            echo "sha256_filename=$(basename "$SHA256_PATHNAME")" >> $GITHUB_OUTPUT
            echo "sha256_path=${SHA256_PATHNAME}" >> $GITHUB_OUTPUT
          fi
          
          echo "Found artifacts:"
          echo "  Main: ${ARTIFACT_NAME}"
          echo "  MD5: $(basename "$MD5_PATHNAME" 2>/dev/null || echo 'none')"
          echo "  SHA1: $(basename "$SHA1_PATHNAME" 2>/dev/null || echo 'none')"
          echo "  SHA256: $(basename "$SHA256_PATHNAME" 2>/dev/null || echo 'none')"
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: crankshaft-refactored-${{ steps.get_version.outputs.builddate }}-${{ steps.get_version.outputs.version }}
          path: |
            crankshaft/deploy/
            crankshaft/work/*/build.log
          retention-days: 30
          
      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-failure-${{ steps.get_version.outputs.builddate }}-${{ steps.get_version.outputs.version }}
          path: |
            crankshaft/work/*/build.log
            crankshaft/work/*/*.log
          retention-days: 7

  # Release job (only runs for specific version patterns)
  release:
    name: Create GitHub Release
    needs: [buildimage]
    if: |
      github.event_name == 'workflow_dispatch' && 
      contains(github.event.inputs.version, 'csng')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: crankshaft-refactored-${{ needs.buildimage.outputs.builddate }}-${{ needs.buildimage.outputs.version }}
          path: artifacts/
          
      - name: Create release notes
        id: release-notes
        run: |
          cat > release_notes.md <<EOF
          # Crankshaft Refactored Build
          
          ## Build Information
          - **Version**: ${{ needs.buildimage.outputs.version }}
          - **Build Date**: ${{ needs.buildimage.outputs.builddate }}
          - **Architecture**: ${{ github.event.inputs.target_arch || 'armhf' }}
          - **Debian Release**: ${{ github.event.inputs.release || 'trixie' }}
          - **Commit**: ${GITHUB_SHA:0:7}
          
          ## Changes in this Build
          This is a refactored version of crankshaft using the latest pi-gen structure:
          
          - Updated to latest pi-gen repository structure
          - Modern build system with improved error handling
          - Support for DEPLOY_COMPRESSION (xz) instead of deprecated DEPLOY_ZIP
          - Updated Docker base image (debian:bookworm)
          - Preserved all crankshaft automotive customizations
          - Better maintainability for future updates
          
          ## Installation
          1. Download the appropriate image file for your architecture
          2. Flash to SD card using Raspberry Pi Imager or similar tool
          3. Insert into your Raspberry Pi and boot
          
          ## Checksums
          Verify your download using the provided MD5, SHA1, or SHA256 checksums.
          EOF
          
      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.buildimage.outputs.version }}
          name: Crankshaft Refactored ${{ needs.buildimage.outputs.version }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ !contains(github.event.inputs.version, 'stable') }}
          files: |
            artifacts/deploy/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Notification job
  notify:
    name: Send Build Notification
    needs: [buildimage]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Build Success Notification
        if: needs.buildimage.result == 'success'
        run: |
          echo "✅ Crankshaft build completed successfully!"
          echo "Version: ${{ needs.buildimage.outputs.version }}"
          echo "Date: ${{ needs.buildimage.outputs.builddate }}"
          
      - name: Build Failure Notification
        if: needs.buildimage.result == 'failure'
        run: |
          echo "❌ Crankshaft build failed!"
          echo "Check the build logs for details."
          exit 1